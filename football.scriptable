{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "deep-green",
    "glyph" : "futbol"
  },
  "name" : "英超联赛英文版",
  "script" : "\n\/\/ Widget customisation\nconst defaultSettings = {\n    teamId: \"8456\",\n    timeZone: \"Asia\/Shanghai\",\n\n    language: \"system\",\n\n    smallWidgetView: args.widgetParameter ? args.widgetParameter : \"table\",\n\n    showMatchesRound: false,\n    showMatchesTeamsNames: true,\n    showMatchesTeamsBadges: false,\n    showMatchesOnlyOpposition: false,\n    showHomeOrAway: false,\n    matchesTwelveHourClock: false,\n    showMatchesDayOfWeek: false,\n    showMatchesLiveTime: false,\n    showLeagueSubtitle: false,\n    showCirclePositionHighlight: true,\n    showRowPositionHighlight: false,\n\n    backgroundColor: {\n        light: \"#ffffff\",\n        dark: \"#1c1c1e\"\n    },\n    leagueTitleColor: {\n        light: \"#ff3b30\",\n        dark: \"#ff453a\"\n    },\n    highlightedPositionColor: {\n        light: \"#ff3b30\",\n        dark: \"#ff453a\"\n    },\n    highlightedRowColor: {\n        light: \"#e5e6ea\",\n        dark: \"#3a3a3c\"\n    },\n    liveColor: {\n        light: \"#ff3b30\",\n        dark: \"#ff453a\"\n    }\n};\n\n\/\/ Create folder to store data\nlet fm = FileManager.local();\nconst iCloudUsed = fm.isFileStoredIniCloud(module.filename);\nfm = iCloudUsed ? FileManager.iCloud() : fm;\nconst widgetFolder = \"Futcal\";\nconst offlinePath = fm.joinPath(fm.documentsDirectory(), widgetFolder);\nif (!fm.fileExists(offlinePath)) fm.createDirectory(offlinePath);\n\n\/\/ Get user settings\nlet userSettings;\nconst userSettingsOffline = \"userSettings.json\";\nif (!fm.fileExists(fm.joinPath(offlinePath, userSettingsOffline))) {\n    userSettings = defaultSettings;\n} else {\n    if (iCloudUsed) await fm.downloadFileFromiCloud(fm.joinPath(offlinePath, userSettingsOffline));\n    userSettings = JSON.parse(fm.readString(fm.joinPath(offlinePath, userSettingsOffline)));\n}\n\n\/\/ Get language settings\nlet language;\nconst supportedLanguages = getDictionary(language)[0];\n\nif (userSettings.language == \"system\") {\n    let systemLanguage = Device.preferredLanguages()[0];\n    language = systemLanguage.split(\"-\")[0];\n} else {\n    language = userSettings.language;\n}\nif (!(supportedLanguages.includes(language))) {\n    console.log(\"Language Error: Language not found, defaulting to English.\")\n    language = \"en\";\n};\nconst dictionary = getDictionary(language)[1];\n\n\/\/ Define FotMob API URLs\nconst baseApiUrl = encodeURI(\"https:\/\/www.fotmob.com\");\nconst teamDataApiUrl = encodeURI(`${baseApiUrl}\/api\/teams?id=${userSettings.teamId}&tab=overview&type=team&timeZone=${userSettings.timeZone}`);\nconst matchDetailsApiUrl = encodeURI(`${baseApiUrl}\/api\/matchDetails?matchId=`);\n\n\/\/ Get team data\nconst teamData = await getData(teamDataApiUrl, \"teamData.json\");\n\n\/\/ Set tap URLs\nconst teamTapUrl = encodeURI(`${baseApiUrl}\/teams\/${userSettings.teamId}\/overview`);\nconst teamMatchesTapUrl = encodeURI(`${baseApiUrl}\/teams\/${userSettings.teamId}\/fixtures`);\nlet leagueTableTapUrl;\nif (teamData && teamData.table) {\n    const leagueOverviewUrl = encodeURI(`${baseApiUrl}${teamData.table[0].data.pageUrl}`);\n    leagueTableTapUrl = leagueOverviewUrl.replace(\"overview\", \"table\");\n}\n\n\/\/ Run\nif (config.runsInWidget) {\n    let widget = await createWidget();\n    Script.setWidget(widget);\n    Script.complete();\n} else {\n    let widget = await createWidget();\n    Script.complete();\n    await widget.presentMedium();\n}\n\n\/\/ *** Functions *** \/\/\n\n\/\/ Create widget UI\nasync function createWidget() {\n    let widget = new ListWidget();\n    widget.backgroundColor = Color.dynamic(new Color(userSettings.backgroundColor.light), new Color(userSettings.backgroundColor.dark));\n    setWidgetBackground(widget);\n\n    let showMatchesView = true;\n    let showTableView = true;\n\n    let paddingLeft = 14;\n    let paddingRight = 13;\n    let paddingTop = 15.5;\n    let paddingBottom = 16;\n\n    if (teamData) {\n        \/\/ By default small widgets will show the Table View, in order to see the Matches View edit the widget and add \"matches\" in the Parameter box\n        if (config.widgetFamily === \"small\") {\n            if (defaultSettings.smallWidgetView === \"matches\") {\n                widget.url = teamMatchesTapUrl;\n                showTableView = false;\n\n                paddingLeft = 10;\n                paddingRight = 10;\n                paddingBottom = 20;\n            } else {\n                widget.url = leagueTableTapUrl;\n                showMatchesView = false;\n\n                paddingLeft = 0;\n                paddingRight = 0;\n            }\n        }\n        widget.setPadding(paddingTop, paddingLeft, paddingBottom, paddingRight);\n\n        const globalStack = widget.addStack();\n        globalStack.url = teamTapUrl;\n\n        if (showMatchesView) {\n            await addWidgetMatches(globalStack);\n        }\n        if (showTableView) {\n            await addWidgetTable(globalStack);\n        }\n    } else {\n        const offlineError = dictionary.noInternetConnection;\n        const errorStack = widget.addStack();\n        addFormattedText(errorStack, offlineError, Font.regularSystemFont(14), Color.gray(), null, true);\n    }\n    return widget;\n}\n\n\/\/ Create matches view\nasync function addWidgetMatches(globalStack) {\n    const nextMatch = teamData.fixtures.allFixtures.nextMatch;\n\n    let previousMatchIndex = teamData.fixtures.allFixtures.fixtures.length - 1;\n    if (nextMatch) {\n      for (let i = 0; i < teamData.fixtures.allFixtures.fixtures.length; i += 1) {\n          if (teamData.fixtures.allFixtures.fixtures[i].id === nextMatch.id) {\n              previousMatchIndex = i - 1;\n              break;\n          }\n      }\n    }\n    const previousMatch = teamData.fixtures.allFixtures.fixtures[previousMatchIndex];\n\n    const matchesStack = globalStack.addStack();\n    matchesStack.url = teamMatchesTapUrl;\n    globalStack.addSpacer();\n    matchesStack.layoutVertically();\n    matchesStack.addSpacer(1.5);\n    await addWidgetMatch(matchesStack, previousMatch, \"Previous\");\n    matchesStack.addSpacer(9.5);\n    const matchesSeparatorStack = matchesStack.addStack();\n    matchesSeparatorStack.addSpacer(2);\n    const separatorValue = (dictionary.matchTitleNext).toUpperCase();\n    addFormattedText(matchesSeparatorStack, separatorValue, Font.semiboldSystemFont(11), Color.gray(), 1, false);\n    matchesStack.addSpacer(3);\n    await addWidgetMatch(matchesStack, nextMatch, \"Next\");\n}\n\n\/\/ Create specific match\nasync function addWidgetMatch(matchesStack, match, title) {\n    matchesStack.addSpacer(2);\n    const matchStack = matchesStack.addStack();\n    matchStack.size = new Size(0, 46);\n\n    if (match != undefined) {\n        const matchTapUrl = encodeURI(`${baseApiUrl}${match.pageUrl}`);\n        matchStack.url = matchTapUrl;\n        const matchDetailsUrl = `${matchDetailsApiUrl}${match.id}`;\n        const matchDetailsOffline = `match${title}.json`;\n        const matchDetails = await getData(matchDetailsUrl, matchDetailsOffline);\n\n        let resultColor = Color.gray();\n        if (matchDetails.header.status.started) {\n            if (match.home.score == match.away.score) {\n                resultColor = Color.yellow();\n            } else if ((matchDetails.header.teams[0].score > matchDetails.header.teams[1].score && match.home.id == teamData.details.id) ||\n                (matchDetails.header.teams[0].score < matchDetails.header.teams[1].score && match.away.id == teamData.details.id)) {\n                resultColor = Color.green();\n            } else {\n                resultColor = Color.red();\n            }\n        }\n        const matchResultBar = matchStack.addStack();\n        const resultBarImage = getResultBar(resultColor);\n        matchResultBar.addImage(resultBarImage);\n        matchStack.addSpacer(5);\n\n        \/\/ Add match information\n        const matchInfoStack = matchStack.addStack();\n        matchInfoStack.layoutVertically();\n        const matchInfoCompetitionStack = matchInfoStack.addStack();\n        matchInfoCompetitionStack.centerAlignContent();\n        const competitionNameValue = replaceText(matchDetails.content.matchFacts.infoBox.Tournament.leagueName);\n        addFormattedText(matchInfoCompetitionStack, competitionNameValue, Font.semiboldSystemFont(13), null, 1, false);\n        if (userSettings.showMatchesRound && matchDetails.content.matchFacts.infoBox.Tournament.round) {\n            matchInfoCompetitionStack.addSpacer(2);\n            const competitionRoundValue = `(${shortenRoundName(matchDetails.content.matchFacts.infoBox.Tournament.round)})`;\n            addFormattedText(matchInfoCompetitionStack, competitionRoundValue, Font.semiboldSystemFont(13), null, 1, false);\n        }\n        matchInfoStack.addSpacer(1);\n\n        \/\/ Add match info\n        const matchInfoTeamsStack = matchInfoStack.addStack();\n        matchInfoTeamsStack.centerAlignContent();\n        if (userSettings.showMatchesOnlyOpposition) {\n            if (userSettings.showMatchesTeamsBadges) {\n                let teamBadgeUrl = match.home.id == teamData.details.id ? encodeURI(`https:\/\/images.fotmob.com\/image_resources\/logo\/teamlogo\/${match.away.id}_xsmall.png`) : encodeURI(`https:\/\/images.fotmob.com\/image_resources\/logo\/teamlogo\/${match.home.id}_xsmall.png`);\n                let teamBadgeOffline = match.home.id == teamData.details.id ? `badge${title}Away.png` : `badge${title}Home.png`;\n                let teamBadgeValue = await getImage(teamBadgeUrl, teamBadgeOffline);\n                let teamBadgeImage = matchInfoTeamsStack.addImage(teamBadgeValue);\n                teamBadgeImage.imageSize = new Size(14, 14);\n                matchInfoTeamsStack.addSpacer(2);\n            }\n            if (userSettings.showMatchesTeamsNames) {\n                const oppositionTeamValue = match.home.id == teamData.details.id ? replaceText(match.away.name) : replaceText(match.home.name);\n                addFormattedText(matchInfoTeamsStack, oppositionTeamValue, Font.regularSystemFont(12), null, 1, false);\n                matchInfoTeamsStack.addSpacer(2);\n            }\n            if (userSettings.showHomeOrAway) {\n                const homeOrAwayValue = match.home.id == teamData.details.id ? `(${dictionary.home})` : `(${dictionary.away})`;\n                addFormattedText(matchInfoTeamsStack, homeOrAwayValue, Font.regularSystemFont(12), null, null, false);\n            }\n        } else {\n            if (userSettings.showMatchesTeamsNames) {\n                const teamsHomeValue = replaceText(match.home.name);\n                addFormattedText(matchInfoTeamsStack, teamsHomeValue, Font.regularSystemFont(12), null, 1, false);\n                matchInfoTeamsStack.addSpacer(2);\n            }\n            if (userSettings.showMatchesTeamsBadges) {\n                let teamBadgeUrl = encodeURI(`https:\/\/images.fotmob.com\/image_resources\/logo\/teamlogo\/${match.home.id}_xsmall.png`);\n                let teamBadgeOffline = `badge${title}Home.png`;\n                let teamBadgeValue = await getImage(teamBadgeUrl, teamBadgeOffline);\n                let teamBadgeImage = matchInfoTeamsStack.addImage(teamBadgeValue);\n                teamBadgeImage.imageSize = new Size(14, 14);\n                matchInfoTeamsStack.addSpacer(2);\n            }\n            const teamsSeparatorValue = \"-\";\n            addFormattedText(matchInfoTeamsStack, teamsSeparatorValue, Font.regularSystemFont(12), null, null, false);\n            if (userSettings.showMatchesTeamsBadges) {\n                matchInfoTeamsStack.addSpacer(2);\n                let teamBadgeUrl = encodeURI(`https:\/\/images.fotmob.com\/image_resources\/logo\/teamlogo\/${match.away.id}_xsmall.png`);\n                let teamBadgeOffline = `badge${title}Away.png`;\n                let teamBadgeValue = await getImage(teamBadgeUrl, teamBadgeOffline);\n                let teamBadgeImage = matchInfoTeamsStack.addImage(teamBadgeValue);\n                teamBadgeImage.imageSize = new Size(14, 14);\n            }\n            if (userSettings.showMatchesTeamsNames) {\n                matchInfoTeamsStack.addSpacer(2);\n                const teamsAwayValue = replaceText(match.away.name);\n                addFormattedText(matchInfoTeamsStack, teamsAwayValue, Font.regularSystemFont(12), null, 1, false);\n            }\n        }\n        matchInfoStack.addSpacer(1);\n\n        \/\/ Add date\/time or result\n        const matchInfoDetailsStack = matchInfoStack.addStack();\n        matchInfoDetailsStack.centerAlignContent();\n        if (!matchDetails.header.status.started) {\n            if (matchDetails.header.status.cancelled) {\n                \/\/ If match is cancelled show reason\n                const detailsCancellationValue = replaceText(matchDetails.header.status.reason.long);\n                addFormattedText(matchInfoDetailsStack, detailsCancellationValue, Font.regularSystemFont(12), Color.gray(), null, false);\n            } else {\n                \/\/ If match is in the future show date and time\n                const detailsDateValue = formatDate(new Date((matchDetails.content.matchFacts.infoBox[\"Match Date\"].utcTime)));\n                addFormattedText(matchInfoDetailsStack, detailsDateValue, Font.regularSystemFont(12), Color.gray(), null, false);\n                matchInfoDetailsStack.addSpacer(3);\n                const detailsTimeValue = formatTime(new Date((`${matchDetails.content.matchFacts.infoBox[\"Match Date\"].utcTime}`)));\n                addFormattedText(matchInfoDetailsStack, detailsTimeValue, Font.regularSystemFont(12), Color.gray(), null, false);\n            }\n        } else {\n            \/\/ If match is in the past or ongoing show result\n            const detailsScoreValue = matchDetails.header.status.scoreStr;\n            addFormattedText(matchInfoDetailsStack, detailsScoreValue, Font.regularSystemFont(12), Color.gray(), null, false);\n            matchInfoDetailsStack.addSpacer(3);\n            if (matchDetails.header.status.started && !matchDetails.header.status.finished) {\n                if (userSettings.showMatchesLiveTime) {\n                    const detailsPlayingTimeValue = `(${replaceText(matchDetails.header.status.liveTime.short)})`;\n                    addFormattedText(matchInfoDetailsStack, detailsPlayingTimeValue, Font.regularSystemFont(12), Color.gray(), null, false);\n                    matchInfoDetailsStack.addSpacer(3);\n                }\n                const detailsLiveValue = \"●\";\n                addFormattedText(matchInfoDetailsStack, detailsLiveValue, Font.semiboldSystemFont(11), Color.dynamic(new Color(userSettings.liveColor.light), new Color(userSettings.liveColor.dark)), null, false);\n            }\n        }\n    } else {\n        const matchInfoStack = matchStack.addStack();\n        matchInfoStack.layoutVertically();\n        const matchInfoDetailsStack = matchInfoStack.addStack();\n        matchInfoDetailsStack.centerAlignContent();\n        const noMatchesValue = dictionary.noDataAvailable;\n        addFormattedText(matchInfoDetailsStack, noMatchesValue, Font.regularSystemFont(12), null, 1, false);\n        matchInfoStack.addSpacer(1);\n        addFormattedText(matchInfoStack, \"\", Font.semiboldSystemFont(13), null, null, false);\n        matchInfoStack.addSpacer(1);\n        addFormattedText(matchInfoStack, \"\", Font.regularSystemFont(12), null, null, false);\n    }\n}\n\nasync function addWidgetTable(stack) {\n  const leagueStack = stack.addStack();\n  leagueStack.layoutVertically();\n  if(teamData.table) {\n    let isSingleTable = teamData.table.length;\n    let leagueTable;\n    let leagueTitle = teamData.table[0].data.leagueName;\n    let leagueSubtitle;\n    \/\/ If league table is not found assume it is a special case with more than one table available\n    if (isSingleTable == 1) {\n      leagueTable = teamData.table[0].data.table.all;\n    }\n    else {\n        let teamFound;\n        let tableIndex = 0;\t\t\n        for (let i = 0; i < teamData.table.length; i += 1) {\n            teamFound = (teamData.table[i].data.table.all).findIndex(obj => obj.id == teamData.details.id);\n            if (teamFound != -1) {\n                tableIndex = i;\n                break;\n            }\n        }\n        leagueTable = teamData.table[tableIndex].data.table.all;\n        leagueSubtitle = teamData.table[tableIndex].data.leagueName;\n        leagueSubtitle = leagueSubtitle.startsWith(\"- \") ? leagueSubtitle.substring(2) : leagueSubtitle;\n    }\n    \/\/ Get team position in league\n    const teamOnLeague = leagueTable[leagueTable.findIndex(obj => obj.id == teamData.details.id)];\n    let teamLeaguePosition = -1;\n    if (teamOnLeague) {\n        teamLeaguePosition = teamOnLeague.idx;\n    }\n\n    leagueStack.url = leagueTableTapUrl;\n    leagueStack.addSpacer(2.5);\n    const leagueTitleStack = leagueStack.addStack();\n    leagueTitleStack.addSpacer(4);\n    const leagueTitleValue = leagueTitle.toUpperCase();\n    addFormattedText(leagueTitleStack, leagueTitleValue, Font.semiboldSystemFont(11), Color.dynamic(new Color(userSettings.leagueTitleColor.light), new Color(userSettings.leagueTitleColor.dark)), 1, false);\n    if (userSettings.showLeagueSubtitle && leagueSubtitle) {\n        leagueTitleStack.addSpacer(2);\n        const leagueSeparatorValue = \"-\";\n        addFormattedText(leagueTitleStack, leagueSeparatorValue, Font.semiboldSystemFont(11), Color.dynamic(new Color(userSettings.leagueTitleColor.light), new Color(userSettings.leagueTitleColor.dark)), 1, false);\n        leagueTitleStack.addSpacer(2);\n        const leagueSubtitleValue = leagueSubtitle.toUpperCase();\n        addFormattedText(leagueTitleStack, leagueSubtitleValue, Font.semiboldSystemFont(11), Color.dynamic(new Color(userSettings.leagueTitleColor.light), new Color(userSettings.leagueTitleColor.dark)), 1, false);\n    }\n    leagueStack.addSpacer(1);\n\n    const hSpacing = config.widgetFamily === \"small\" ? 17 : 19.2;\n    const vSpacing = 18.4;\n    const leagueTableStack = leagueStack.addStack();\n    leagueTableStack.layoutVertically();\n    const tableInfo = getTable(leagueTable, teamLeaguePosition);\n    const table = tableInfo[0];\n    const highlighted = tableInfo[1];\n    for (let i = 0; i < table.length; i += 1) {\n        let leagueTableRowStack = leagueTableStack.addStack();\n        leagueTableRowStack.spacing = 2;\n        for (let j = 0; j < table[i].length; j += 1) {\n            let cellDataStack = leagueTableRowStack.addStack();\n            cellDataStack.size = new Size(hSpacing, vSpacing);\n            cellDataStack.centerAlignContent();\n            if (j == 0 && i == highlighted) {\n                if (userSettings.showRowPositionHighlight) leagueTableRowStack.backgroundColor = Color.dynamic(new Color(userSettings.highlightedRowColor.light), new Color(userSettings.highlightedRowColor.dark));\n                if (userSettings.showCirclePositionHighlight) {\n                    const highlightedPositionImage = getPositionHighlight((teamLeaguePosition).toString(), Color.dynamic(new Color(userSettings.highlightedPositionColor.light), new Color(userSettings.highlightedPositionColor.dark)));\n                    cellDataStack.addImage(highlightedPositionImage);\n                } else {\n                    let cellDataValue = `${table[i][j]}`;\n                    addFormattedText(cellDataStack, cellDataValue, Font.semiboldSystemFont(10), null, null, true);\n                }\n            } else if (j == 1 && i > 0) {\n                let teamBadgeUrl = encodeURI(`https:\/\/images.fotmob.com\/image_resources\/logo\/teamlogo\/${table[i][j]}_xsmall.png`);\n                let teamBadgeOffline = `badge_${i}.png`;\n                let teamBadgeValue = await getImage(teamBadgeUrl, teamBadgeOffline);\n                let teamBadgeImage = cellDataStack.addImage(teamBadgeValue);\n                teamBadgeImage.imageSize = new Size(14, 14);\n            } else {\n                let cellDataValue = `${table[i][j]}`;\n                addFormattedText(cellDataStack, cellDataValue, Font.semiboldSystemFont(10), null, null, true);\n            }\n        }\n    }\n  } else {\n      leagueStack.addSpacer();\n      const noDataStack = leagueStack.addStack();\n      noDataStack.addSpacer();\n      const noMatchesValue = dictionary.noDataAvailable;\n      addFormattedText(noDataStack, noMatchesValue, Font.regularSystemFont(12), null, 1, false);\n      noDataStack.addSpacer();\n      leagueStack.addSpacer();\n  }\n}\n\n\/\/ Build the league table (Position, Team, Matches Played, Wins, Draws, Losses, Points)\nfunction getTable(leagueTable, teamLeaguePosition) {\n    const table = [\n        \/\/ Table header\n        [\n            \"#\",\n            dictionary.tableHeaderTeam,\n            dictionary.tableHeaderPlayed,\n            dictionary.tableHeaderWins,\n            dictionary.tableHeaderDraws,\n            dictionary.tableHeaderLosses,\n            dictionary.tableHeaderPoints\n        ],\n    ];\n    const teamsToShow = Math.min(5, leagueTable.length);\n    const teamsAbove = Math.ceil((teamsToShow - 1) \/ 2);\n    const teamsBelow = Math.floor((teamsToShow - 1) \/ 2);\n    \/\/ By default show 2 teams above selected team and 2 teams below selected team (5 rows in total)\n    let initial = teamLeaguePosition - teamsAbove;\n    let final = teamLeaguePosition + teamsBelow;\n    \/\/ By default highlight selected team, in the middle row\n    let highlighted = teamsToShow - teamsBelow;\n    if (teamLeaguePosition == -1) {\n        \/\/ If team selected not found show 5 top teams and do not highlight any\n        initial = 1;\n        final = initial + 4;\n        highlighted = -1;\n        console.log(\"League Table Error: Team not found in the selected league, showing top teams.\");\n    } else if (teamLeaguePosition <= teamsAbove) {\n        \/\/ If team selected in first place show 5 top teams and highlight first row\n        initial = 1;\n        final = teamsToShow <= leagueTable.length ? teamsToShow : leagueTable.length;\n        highlighted = teamLeaguePosition;\n    } else if (teamLeaguePosition > leagueTable.length - teamsBelow) {\n        \/\/ If team selected in first place show 5 top teams and highlight first row\n        initial = leagueTable.length - teamsToShow >= 0 ? leagueTable.length - teamsToShow + 1 : 1;\n        final = leagueTable.length;\n        highlighted = teamLeaguePosition - initial + 1;\n    }\n\n    for (let i = initial; i < final + 1; i += 1) {\n        \/\/ Add table data, row by row\n        table.push(\n            [\n                i,\n                leagueTable[i - 1].id,\n                leagueTable[i - 1].played,\n                leagueTable[i - 1].wins,\n                leagueTable[i - 1].draws,\n                leagueTable[i - 1].losses,\n                leagueTable[i - 1].pts\n            ]\n        );\n    }\n    return [table, highlighted];\n}\n\n\/\/ Return the team badge\nasync function getImage(url, cachedFileName) {\n    let image;\n    try {\n        image = await new Request(url).loadImage();\n        fm.writeImage(fm.joinPath(offlinePath, cachedFileName), image);\n    } catch (err) {\n        console.log(`${err} Trying to read cached data: ${cachedFileName}`);\n        try {\n            if (iCloudUsed) await fm.downloadFileFromiCloud(fm.joinPath(offlinePath, cachedFileName));\n            image = fm.readImage(fm.joinPath(offlinePath, cachedFileName));\n        } catch (err) {\n            console.log(`${err}`);\n        }\n    }\n    return image;\n}\n\nasync function getData(url, cachedFileName) {\n    let data;\n    try {\n        data = await new Request(url).loadJSON();\n        fm.writeString(fm.joinPath(offlinePath, cachedFileName), JSON.stringify(data));\n    } catch (err) {\n        console.log(`${err} Trying to read cached data: ${cachedFileName}`);\n        try {\n            if (iCloudUsed) await fm.downloadFileFromiCloud(fm.joinPath(offlinePath, cachedFileName));\n            data = JSON.parse(fm.readString(fm.joinPath(offlinePath, cachedFileName)));\n        } catch (err) {\n            console.log(`${err}`);\n        }\n    }\n    return data;\n}\n\n\/\/ Draws a circle on the team current position in the league table\nfunction getPositionHighlight(position, color) {\n    const drawContext = new DrawContext();\n    drawContext.respectScreenScale = true;\n    const size = 50;\n    drawContext.size = new Size(size, size);\n    drawContext.opaque = false;\n    drawContext.setFillColor(color);\n    drawContext.fillEllipse(new Rect(1, 1, size - 2, size - 2));\n    drawContext.setFont(Font.semiboldSystemFont(27));\n    drawContext.setTextAlignedCenter();\n    drawContext.setTextColor(new Color(\"#ffffff\"));\n    drawContext.drawTextInRect(position, new Rect(0, 8.5, size, size));\n    const positionHighlightImage = drawContext.getImage();\n    return positionHighlightImage;\n}\n\nfunction getResultBar(resultColor) {\n    const drawContext = new DrawContext();\n    drawContext.size = new Size(10, 115);\n    drawContext.respectScreenScale = true;\n    drawContext.opaque = false;\n    drawContext.setStrokeColor(resultColor);\n    drawContext.setLineWidth(10);\n    const path = new Path();\n    path.move(new Point(5, 5));\n    path.addLine(new Point(5, 110));\n    drawContext.addPath(path);\n    drawContext.strokePath();\n    drawContext.setFillColor(resultColor);\n    drawContext.fillEllipse(new Rect(0, 0, 10, 10));\n    drawContext.fillEllipse(new Rect(0, 105, 10, 10));\n    const resultBarImage = drawContext.getImage();\n    return resultBarImage;\n}\n\nfunction addFormattedText(stack, string, font, textColor, lineLimit, center) {\n    const text = stack.addText(string);\n    text.font = font;\n    if (lineLimit) text.lineLimit = lineLimit;\n    if (textColor) text.textColor = textColor;\n    if (center) text.centerAlignText();\n}\n\n\/\/ Formats the event date into day and month (format 01\/Jan)\nfunction formatDate(date) {\n    if (isToday(date)) {\n        return dictionary.matchDateToday;\n    } else if (isTomorrow(date)) {\n        return dictionary.matchDateTomorrow;\n    } else {\n        const dateFormatter = new DateFormatter();\n        dateFormatter.dateFormat = userSettings.showMatchesDayOfWeek ? \"EEE dd\/MMM\" : \"dd\/MMM\";\n        \/\/ Format will depend on device language\n        dateFormatter.locale = (language);\n        return dateFormatter.string(date);\n    }\n}\n\nfunction formatTime(date) {\n    let hours = date.getHours();\n    let minutes = date.getMinutes();\n    minutes = minutes < 10 ? `0${minutes}` : minutes;\n    let time;\n    if (userSettings.matchesTwelveHourClock) {\n        const ampm = hours >= 12 ? \"pm\" : \"am\";\n        hours = hours % 12;\n        hours = hours ? hours : 12; \/\/ the hour '0' should be '12'\n        time = `${hours}:${minutes}${ampm}`;\n    } else {\n        time = `${hours}:${minutes}`;\n    }\n    return time;\n}\n\n\/\/ Check if date is today\nfunction isToday(date) {\n    const today = new Date();\n    return (date.getDate() == today.getDate() &&\n        date.getMonth() == today.getMonth() &&\n        date.getFullYear() == today.getFullYear());\n}\n\n\/\/ Check if date is tomorrow\nfunction isTomorrow(date) {\n    const today = new Date();\n    const tomorrow = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 1);\n    return (date.getDate() == tomorrow.getDate() &&\n        date.getMonth() == tomorrow.getMonth() &&\n        date.getFullYear() == tomorrow.getFullYear());\n}\n\n\/\/ Look for backgroundImage in folder and if available use it as background\nfunction setWidgetBackground(widget) {\n    const backgroundImage = \"background.png\";\n    const imageUrl = fm.joinPath(offlinePath, backgroundImage);\n    widget.backgroundImage = Image.fromFile(imageUrl);\n}\n\n\/\/ Prepare league and round name to fit in widget\nfunction shortenRoundName(roundName) {\n        if (roundName.includes(\"Round\")) {\n            if (roundName.includes(\"of\")) {\n                \/\/ Replace \"Round of X\" with \"1\/X\"\n                roundName = `1\/${roundName.split(\"Round of \")[1]}`;\n            } else {\n                \/\/ Replace \"Round X\" with \"RX\" (language dependent)\n                roundName = `${dictionary.matchRound}${roundName.split(\"Round \")[1]}`;\n            }\n        }\n        return replaceText(roundName);\n}\n\n\/\/ Shorten and \/ or translate specific information\nfunction replaceText(string) {\n    const text = {\n        \/\/ Tournaments\n        \"Champions League Qualification\": dictionary.championsLeagueQualification,\n        \"Europa League Qualification\": dictionary.europaLeagueQualification,\n        \"Cup\": dictionary.cup,\n        \"League Cup\": dictionary.leagueCup,\n        \"Super Cup\": dictionary.superCup,\n        \"Club Friendlies\": dictionary.clubFriendlies,\n        \/\/ Rounds\n        \"Quarter-Final\": dictionary.quarterFinal,\n        \"Semi-Final\": dictionary.semiFinal,\n        \"Final\": dictionary.final,\n        \/\/ Cancel reasons\n        \"Postponed\": dictionary.postponed,\n        \"Cancelled\": dictionary.cancelled,\n        \/\/Live time\n        \"HT\": dictionary.halfTime,\n        \/\/ Teams\n        \"Sporting CP\": \"Sporting\",\n        \"Famalicao\": \"Famalicão\",\n        \"Pacos de Ferreira\": \"P. Ferreira\",\n        \"Vitoria de Guimaraes\": \"V. Guimarães\",\n        \"Belenenses SAD\": \"Belenenses\",\n        \"FC Porto\": \"Porto\"\n    };\n\n    if (text[string]) {\n        return text[string];\n        \/\/ Special cases - includes\n    } else if (string.includes(\"Champions League\")) {\n        return dictionary.championsLeague;\n    } else if (string.includes(\"Europa League\")) {\n        return dictionary.europaLeague;\n    } else if (string.includes(\"UEFA Super Cup\")) {\n        return dictionary.uefaSuperCup;\n    } else {\n        return string;\n    }\n}\n\n\/\/ Multi language dictionary\nfunction getDictionary(language) {\n    const text = {\n        en: {\n            championsLeague: \"Champions League\",\n            championsLeagueQualification: \"Champions League Q.\",\n            europaLeague: \"Europa League\",\n            europaLeagueQualification: \"Europa League Q.\",\n            uefaSuperCup: \"UEFA Super Cup\",\n            cup: \"Cup\",\n            leagueCup: \"League Cup\",\n            superCup: \"Super Cup\",\n            clubFriendlies: \"Friendly\",\n            quarterFinal: \"QF\",\n            semiFinal: \"SF\",\n            final: \"F\",\n            matchTitleNext: \"Next\",\n            matchRound: \"R\",\n            home: \"H\",\n            away: \"A\",\n            matchDateToday: \"Today\",\n            matchDateTomorrow: \"Tomorrow\",\n            postponed: \"Postponed\",\n            cancelled: \"Cancelled\",\n            halfTime: \"HT\",\n            tableHeaderTeam: \"T\",\n            tableHeaderPlayed: \"M\",\n            tableHeaderWins: \"W\",\n            tableHeaderDraws: \"D\",\n            tableHeaderLosses: \"L\",\n            tableHeaderPoints: \"P\",\n            noDataAvailable: \"No data\",\n            noInternetConnection: \"Internet connection required\"\n        },\n        pt: {\n            championsLeague: \"Liga Campeões\",\n            championsLeagueQualification: \"Q. Liga Campeões\",\n            europaLeague: \"Liga Europa\",\n            europaLeagueQualification: \"Q. Liga Europa\",\n            uefaSuperCup: \"Supertaça Europeia\",\n            cup: \"Taça\",\n            leagueCup: \"Taça Liga\",\n            superCup: \"Supertaça\",\n            clubFriendlies: \"Amigável\",\n            quarterFinal: \"QF\",\n            semiFinal: \"MF\",\n            final: \"F\",\n            matchTitleNext: \"Próximo\",\n            matchRound: \"J\",\n            home: \"C\",\n            away: \"F\",\n            matchDateToday: \"Hoje\",\n            matchDateTomorrow: \"Amanhã\",\n            postponed: \"Adiado\",\n            cancelled: \"Cancelado\",\n            halfTime: \"Int\",\n            tableHeaderTeam: \"E\",\n            tableHeaderPlayed: \"J\",\n            tableHeaderWins: \"V\",\n            tableHeaderDraws: \"E\",\n            tableHeaderLosses: \"D\",\n            tableHeaderPoints: \"P\",\n            noDataAvailable: \"Sem dados\",\n            noInternetConnection: \"Necessária ligação à internet\"\n        },\n        es: {\n            championsLeague: \"Champions League\",\n            championsLeagueQualification: \"C. Champions League\",\n            europaLeague: \"Europa League\",\n            europaLeagueQualification: \"C. Europa League\",\n            uefaSuperCup: \"Supercopa UEFA\",\n            cup: \"Copa\",\n            leagueCup: \"Copa Liga\",\n            superCup: \"Supercopa\",\n            clubFriendlies: \"Amistoso\",\n            quarterFinal: \"CF\",\n            semiFinal: \"SF\",\n            final: \"F\",\n            matchTitleNext: \"Siguiente\",\n            matchRound: \"J\",\n            home: \"L\",\n            away: \"V\",\n            matchDateToday: \"Hoy\",\n            matchDateTomorrow: \"Mañana\",\n            postponed: \"Aplazado\",\n            cancelled: \"Cancelado\",\n            halfTime: \"ET\",\n            tableHeaderTeam: \"E\",\n            tableHeaderPlayed: \"J\",\n            tableHeaderWins: \"G\",\n            tableHeaderDraws: \"E\",\n            tableHeaderLosses: \"P\",\n            tableHeaderPoints: \"PT\",\n            noDataAvailable: \"Sin datos\",\n            noInternetConnection: \"Requiere conexión a internet\"\n        },\n        fr: {\n            championsLeague: \"Ligue Champions\",\n            championsLeagueQualification: \"Q. Ligue Champions\",\n            europaLeague: \"Ligue Europa\",\n            europaLeagueQualification: \"Q. Ligue Europa\",\n            uefaSuperCup: \"Supercoupe d'Europe\",\n            cup: \"Coupe\",\n            leagueCup: \"League Cup\",\n            superCup: \"Supercoupe\",\n            clubFriendlies: \"Amical\",\n            quarterFinal: \"QF\",\n            semiFinal: \"DF\",\n            final: \"F\",\n            matchTitleNext: \"Suivant\",\n            matchRound: \"J\",\n            home: \"D\",\n            away: \"E\",\n            matchDateToday: \"Aujourd'hui\",\n            matchDateTomorrow: \"Demain\",\n            postponed: \"Reporté\",\n            cancelled: \"Annulé\",\n            halfTime: \"MT\",\n            tableHeaderTeam: \"C\",\n            tableHeaderPlayed: \"M\",\n            tableHeaderWins: \"G\",\n            tableHeaderDraws: \"N\",\n            tableHeaderLosses: \"P\",\n            tableHeaderPoints: \"PT\",\n            noDataAvailable: \"Pas de données\",\n            noInternetConnection: \"Connexion Internet requise\"\n        },\n        de: {\n            championsLeague: \"Champions League\",\n            championsLeagueQualification: \"Champions League Q.\",\n            europaLeague: \"Europa League\",\n            europaLeagueQualification: \"Europa League Q.\",\n            uefaSuperCup: \"UEFA Supercup\",\n            cup: \"DFB-Pokal\",\n            leagueCup: \"Ligapokal\",\n            superCup: \"Supercup\",\n            clubFriendlies: \"Testspiel\",\n            quarterFinal: \"VF\",\n            semiFinal: \"HF\",\n            final: \"F\",\n            matchTitleNext: \"Nächstes\",\n            matchRound: \"S\",\n            home: \"H\",\n            away: \"A\",\n            matchDateToday: \"Heute\",\n            matchDateTomorrow: \"Morgen\",\n            postponed: \"Verlegt\",\n            cancelled: \"Abgesagt\",\n            halfTime: \"HZ\",\n            tableHeaderTeam: \"M\",\n            tableHeaderPlayed: \"S\",\n            tableHeaderWins: \"G\",\n            tableHeaderDraws: \"U\",\n            tableHeaderLosses: \"V\",\n            tableHeaderPoints: \"P\",\n            noDataAvailable: \"Keine Daten\",\n            noInternetConnection: \"Internetverbindung erforderlich\"\n        },\n        cs: {\n            championsLeague: \"Liga mistrů\",\n            championsLeagueQualification: \"Liga mistrů K.\",\n            europaLeague: \"Evropská liga\",\n            europaLeagueQualification: \"Evropská liga K.\",\n            uefaSuperCup: \"Superpohár UEFA\",\n            cup: \"Pohár\",\n            leagueCup: \"Ligový pohár\",\n            superCup: \"Super pohár\",\n            clubFriendlies: \"Prátelák\",\n            quarterFinal: \"ČF\",\n            semiFinal: \"SF\",\n            final: \"F\",\n            matchTitleNext: \"Další\",\n            matchRound: \"K\",\n            home: \"D\",\n            away: \"V\",\n            matchDateToday: \"Dnes\",\n            matchDateTomorrow: \"Zítra\",\n            postponed: \"Přeloženo\",\n            cancelled: \"Zrušeno\",\n            halfTime: \"Pol\",\n            tableHeaderTeam: \"T\",\n            tableHeaderPlayed: \"Z\",\n            tableHeaderWins: \"V\",\n            tableHeaderDraws: \"R\",\n            tableHeaderLosses: \"P\",\n            tableHeaderPoints: \"B\",\n            noDataAvailable: \"Žádná data\",\n            noInternetConnection: \"Vyžadováno internetové připojení\"\n        },\n        ko: {\n            championsLeague: \"챔피언스 리그\",\n            championsLeagueQualification: \"챔피언스 리그 예선\",\n            europaLeague: \"유로파 리그\",\n            europaLeagueQualification: \"유로파 리그 예선\",\n            uefaSuperCup: \"UEFA 슈퍼 컵\",\n            cup: \"컵\",\n            leagueCup: \"리그 컵\",\n            superCup: \"슈퍼 컵\",\n            clubFriendlies: \"친선\",\n            quarterFinal: \"8강\",\n            semiFinal: \"4강\",\n            final: \"결승\",\n            matchTitleNext: \"다음\",\n            matchRound: \"R\",\n            home: \"홈\",\n            away: \"원\",\n            matchDateToday: \"오늘\",\n            matchDateTomorrow: \"내일\",\n            postponed: \"연기됨\",\n            cancelled: \"취소됨\",\n            halfTime: \"하프\",\n            tableHeaderTeam: \"팀\",\n            tableHeaderPlayed: \"경기\",\n            tableHeaderWins: \"승\",\n            tableHeaderDraws: \"무\",\n            tableHeaderLosses: \"패\",\n            tableHeaderPoints: \"승점\",\n            noDataAvailable: \"정보 없음\",\n            noInternetConnection: \"인터넷 연결 필요\"\n        }\n    };\n    return [Object.keys(text), text[language]];\n}\n",
  "share_sheet_inputs" : [

  ]
}